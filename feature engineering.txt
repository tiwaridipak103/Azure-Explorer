import psutil
import matplotlib.pyplot as plt
import time

# Enable interactive mode
plt.ion()

# Initialize the plot only once
fig, ax = plt.subplots()
bars = ax.bar(range(psutil.cpu_count()), [0] * psutil.cpu_count(), color='blue')

ax.set_ylim(0, 100)
ax.set_xlabel("CPU Core")
ax.set_ylabel("Usage (%)")
ax.set_title("Live CPU Usage per Core")

def test(core_id):
    cpu_usage = psutil.cpu_percent(percpu=True)  # Get CPU usage for each core

    for bar, usage in zip(bars, cpu_usage):  # Update bar heights
        bar.set_height(usage)

    fig.canvas.draw()  # Redraw the plot
    fig.canvas.flush_events()  # Flush events for live update

while True:
    test(45)  # Call the function
    time.sleep(2)  # Wait before updating again



import psutil
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
import time

# Enable Seaborn style
sns.set_style("darkgrid")

# Enable interactive mode
plt.ion()

# Initialize the plot
fig, ax = plt.subplots(figsize=(10, 6))

# Get number of CPU cores
num_cores = psutil.cpu_count()

# Create bars with initial height 0
bars = ax.bar(range(num_cores), [0] * num_cores, color='blue', alpha=0.7)

# Set axis labels and title
ax.set_ylim(0, 100)
ax.set_xlabel("CPU Core", fontsize=12)
ax.set_ylabel("Usage (%)", fontsize=12)
ax.set_title("Live CPU Usage per Core", fontsize=14, fontweight='bold')

# Add grid lines for better readability
ax.yaxis.grid(True, linestyle="--", alpha=0.7)

# Add text labels on top of bars
text_labels = [ax.text(bar.get_x() + bar.get_width() / 2, 0, "0%", 
                        ha='center', va='bottom', fontsize=10, fontweight='bold') 
               for bar in bars]

def update_plot():
    cpu_usage = psutil.cpu_percent(percpu=True)  # Get CPU usage per core

    for bar, usage, text in zip(bars, cpu_usage, text_labels):
        bar.set_height(usage)  # Update bar height
        
        # Change color based on CPU load
        if usage < 40:
            bar.set_color("green")
        elif usage < 80:
            bar.set_color("orange")
        else:
            bar.set_color("red")

        # Update text label position & value
        text.set_y(usage + 2)
        text.set_text(f"{usage:.1f}%")

    fig.canvas.draw()  # Redraw plot
    fig.canvas.flush_events()  # Flush updates

# Run the live update loop
while True:
    update_plot()
    time.sleep(1)  # Refresh every second